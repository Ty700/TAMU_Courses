We will discuss what is RISC-V ISA <- Used throughout the remaining of the semester

Review: Load/Store Architectures
    - No memory reference per ALU instruction 
        - 3 address general purpose register (GPR)
    - Register to register arithmetic 
    - Load and store with simple addressing modes (reg + immediate)
    - Simple conditionals 
        - Compare ops -> if true branch
        - Compare&branch 
        - Condition code + branch on condition 
    - Simple fixed-formate encoding 

    Jump:
        op | offset
    
    Immediate:
        op | r | r | immediate value 

    Forgot:
        op | r | r | blank

Instruction Set Architecture 
    - Class of ISA 
        - Most critical feature of instruction set architecture is the internal storage 
        - General-purpose registers
        - Register-memory vs load-store (register-register)
    RISC-V registers
        - 32 GPRs and 32 FP
    
    RISC-V Register Table:
    Register    | Name      | User              | Saver
    x0          | Zero      | Constant 0        | N/A
    x1          | ra        | return addr       | caller
    x2          | sp        | stack pointer     | callee
    x3          | gp        | global pointer    | N/ALU
    x4          | tp        | thread pointer    | 
    x5-x7       | t0-t2     | temps             | caller 
    x8          | s0/fp     | saved/frame ptr   | callee
    x9          | s1        | saved             | callee
    x10-x17     | a0-a7     | arguments         | caller 
    x18-x27     | s2-s11    | saved             | callee
    x28-x31     | t3-t6     | temps             | caller 
    f0-f7       | ft0 - ft7 | FP temps          | caller 
    f8-f9       | fs0-fs1   | FP saved          | callee
    f10-f17     | fa0-fa7   | FP arguments      | callee
    f18-f27     | fs2-fs21  | FP saved          | callee
    fs28-fs31   | ft8-ft11  | FP temps          | caller 

    Notes:
        FP -> Floating Point register 

    Register
        - the x is to indicate it's a register
        - x0 translates to 00000 
            - why 5 0s? 32 registers. Thus need a 5 bit address to access all 32 registers 
    Name
        - for ASM code 
        - for human to understand what register 
    
    Memory addressing
        - RISC-v: Byte Addressed
            - aligned thus faster access time
            Example:
                addr + 1 => addr + 1 byte 

    Addressing modes
        - RISC-V: Register, immediate, displacement (base + offset)
        - Other examples: autoincrement, indexed, PC-relative
    
    Types and Size of operands
        - RISC-V: 8-bit, 32-bit, 64-bit

    Operations for RISC-V:
        1. Data transfer
        2. arithmetic
        3. Logical
        4. Control
        5. FP  
            - See Fig 1.5 in textbook

    Control Flow Instructions
        - Use content of registers (RISC-V) vs Status Bits (x86, ARMv7, ARMv8)
        - Return address in register (RISC-V, ARMv7, ARMv8) vs. on stack (x86)
    
    Encoding
        - Fixed (RISC-V, ARMv7/v8 except compact instruction set) vs variable length (x86)
        
RISC-V Instruction Layout *IMPORTANT*
    R-Type:
        +31-----------25|24-----20|19-----15|14--12|11-----7|6-----0+
        |    func7      |   rs2   |   rs1   |funct3|   rd  | opcode |
        +-----------------------------------------------------------+

        Primary Use:
            - Register-Register 
            - ALU Instructions 

        rd:
            - Destination (Output register)
        
        rs1:
            - Source 1 Register (Operand 1)
        
        rs2:
            - Source 2 Register (Operand 2)

        Immediate:
            N/A

    I-Type:
        +31---------------------20|19-----15|14--12|11-----7|6-----0+
        |       imm[11:0]         |   rs1   |funct3|   rd  | opcode |
        +-----------------------------------------------------------+

        Primary Use:
            - ALU Immediates
            - Load 
        
        rd: 
            Destination (Output register)

        rs1:
            First source 
                - "Base source"
                - Register that holds the value the immediate will Add/Sub/Multiply/Divide to 
        
        rs2:
            N/A
        
        Immediate:
            - Value displacement
                Example:
                    1. 4
                    2. 100
                    - Any valid number

    S-Type:
        +31------------25|24----20|19-----15|14--12|11-----7|6-----0+
        |   imm[11:5]    |  rs2   |   rs1   |funct3|imm[4:0]| opcode|
        +-----------------------------------------------------------+

        Primary Use:
            - Store 
            - Compare and Branch
        
        rd:
            N/A 
        
        rs1:
            - Base register first source 

        rs2:
            - Data source to store second source 

        Immediate:
            - Displacement offset
    U-Type:
        +31--------------------------------------12|11-----7|6-----0+
        |               imm[31:12]                 |   rd  | opcode |
        +-----------------------------------------------------------+

        Primary Use:
            - Jump and link
            - Jump and link register 

        rd:
            - Register destination for return PC 

        rs1:
            - Target address for jump and link register

        rs2:
            N/A 

        Immediate:
            - Target address for jump and link 

    Notes on the 4 types:
        OPCode (first 7 bits) tells what type the instruction belongs to 
            - Then depending on the type the cpu knows how to chop the remaining bits 

        I-Type:
            Operands are immediate data
            Destination is 5 bits for a register 
            Funct3 will tell ALU which operation -> Add/Sub/Multiply/Divide
            RS1 -> Value you are manipulating
            RS2 -> Value that does the manipulating

        S-Type:
            Branch will belong to this type 
            First 7 bits (opcode) will tell it that it's Store
            Storing register value to memory 
            Base address (rs1) + displacement address (immediate) 
            RS2 register value will be send to RS1 + immediate address value 

        U-Type:
            Just a jump 
                How is branch different to jump?
                    Branch = Condition
                    Jump = No condition 

            The immediate value will be added to the current PC and then will jump to that address to fetch more instructions 

Load/Store Instructions in RISC-V *IMPORTANT*
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    |Example Instruction         | Instruction Name     |                             Meaning                                   |                  
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | ld x1,80(x2)               |   Load Doubleword    |       Regs[x1] <- Mem[80 + Regs[x2]]                                  |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | lw x1,60(x2)               |  Load word           |       Regs[x1] <- 64(Mem[60 + Regs[x2]])^32                           |
    +----------------------------+----------------------+-----------------------------------------------------------------------+          
    | lwu x1,60(x2)              |  Load word unsigned  |       Regs[x1] <- [63:33] = 0s [32:0]Mem[60 + Regs[x2]]               |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | lb x1,40(x3)               | Load byte            |       Regs[x1] <- [63:56] = (Mem[40 + Regs[x3]]) and [55:0] = 0s      |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | lbu x1,40(x3)              | Load byte unsigned   |       Regs[x1] <- Mem[40 + Regs[x3]]                                  |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | lh x1,40(x3)               | Load halfword        |       Regs[x1] <- (Mem[40 + Regs[x3]])                                |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | flw f0,50(x3)              | Load FP single       |       Regs[f0] <- (Mem[50] + Regs[x3])                                |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | fld f0,50(x2)              | Load FP double       |       Regs[f0] <- (Mem[50 + Regs[x2]])                                |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | sd x2,400(x3)              | Store double         |       Mem[400 + Regs[x3]] <- (Regs[x2])                               |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | sw x3,500(x4)              | Store word           |       Mem[500 + Regs[x3]] <- (Regs[x3])                               |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | fsw f0,40(x3)              | Store FP single      |       Mem[40 + Regs[x3]] <- (Regs[f0])                                |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | fsd f0,40(x3)              | Store FP double      |       Mem[40 + Regs[x3]] <- Regs[f0]                                  |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | sh x3,502(x2)              | Store half           |       [63:48] of Mem[40 + Regs[x3]] <- Lower 16 bits of Regs[x3]      |
    +----------------------------+----------------------+-----------------------------------------------------------------------+
    | sb x2,41(x3)               | Store byte           |       [63:56] of Mem[41 + Regs[x3]] <- Lower 8 bits of Regs[x2]       |
    +----------------------------+----------------------+-----------------------------------------------------------------------+

ALU Instructions in RISC-V (R & I Type) 
    +--------------------+-------------------------------+-------------------------------------------------------------------+
    |Example             | Instruction Name              |                              Meaning                              |
    +--------------------+-------------------------------+-------------------------------------------------------------------+   
    |add x1,x2,x3        | Add                           | Regs[x1] <- Regs[x2] + Regs[x3]                                   |
    +--------------------+-------------------------------+-------------------------------------------------------------------+  
    |addi x1,x2,3        | Add immediate                 | Regs[x1] <- Regs[x2] + 3                                          |
    +--------------------+-------------------------------+-------------------------------------------------------------------+
    |lui x1,42           | Load Upper immediate          | Regsx[x1] <- Upper bits of 42 will be loaded                      |
    +--------------------+-------------------------------+-------------------------------------------------------------------+
    |sll x1,x2,5         | Shift left logical            | Regs[x1] <- Regs[x2]<<5                                           |
    +--------------------+-------------------------------+-------------------------------------------------------------------+
    |slt x1,x2,x3        | Set less than                 | if(Regs[x2] < Regs[x3]) then: Regs[x1] <- 1 else Regs[x0] <- 0    |
    +--------------------+-------------------------------+-------------------------------------------------------------------+

Control Flow instructions in RISC-V 
    S-Type (Branch) vs U-Type (Jump and link)
        +--------------------+-------------------------------+-------------------------------------------------------------------+
        |Example             | Instruction Name              |                              Meaning                              |
        +--------------------+-------------------------------+-------------------------------------------------------------------+   
        |jal x1, offset      | Jump and link                 | Regs[x1] <- PC + 4; PC <- PC + (offset<<1)                        |
        +--------------------+-------------------------------+-------------------------------------------------------------------+
        |jalr x1,x2,offset   | Jump and link register        | Regs[x1] <- PC + 4; PC <- Regs[x2]+offset                         |
        +--------------------+-------------------------------+-------------------------------------------------------------------+
        |beq x3,x4,offset    | Branch equal Zero             | if (Regs[x3] == Regs[x4]) PC <- PC + (offset<<1)                  |
        +--------------------+-------------------------------+-------------------------------------------------------------------+
        |bgt x4,x4,name      | Branch not equal zero         | if (Regs[x3] > Regs[x4]) PC <- PC + (offset<<1)                   |
        +--------------------+-------------------------------+-------------------------------------------------------------------+

Execution Cycle

+-----------+
|           |
|           |
|           V
|    +---------------+
|    | Instruction   | 
|    |   Fetch       |
|    +---------------+
|            |
|            | Obtain instruction from program storage
|            |
|            V 
|    +---------------+
|    | Instruction   | 
|    |   Decode      |
|    +---------------+
|            |
|            | Determine required actions and instruction size 
|            |
|            V 
|    +---------------+
|    |   Operand     | 
|    |   Fetch       |
|    +---------------+
|            |
|            | Locate and obtain operand data
|            |
|            V 
|    +---------------+
|    |   Execute     |
|    +---------------+
|            |
|            | Compute result value or status
|            |
|            V
|    +---------------+
|    |   Result      | 
|    |     Store     |
|    +---------------+
|            |
|            | Deposit reslts in storage for later use
|            |
|            V
|    +---------------+
|    | Next          | 
|    |   Instruction |
|    +---------------+
|            |
|            | Determine successor instruction
|            |
+------------+